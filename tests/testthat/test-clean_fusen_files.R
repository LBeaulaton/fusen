# WARNING - Generated by {fusen} from dev/flat_clean_fusen_files.Rmd: do not edit by hand

# Or you can try on the reproducible example
dummypackage <- tempfile("register")
dir.create(dummypackage)
dir.create(file.path(dummypackage, "fusentest"))
dummypackage_fixed <- file.path(dummypackage, "fusentest")
# unlink(dummypackage, recursive = TRUE)
# {fusen} steps
fill_description(pkg = dummypackage_fixed, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(add_flat_template(pkg = dummypackage_fixed, overwrite = TRUE, open = FALSE))
flat_file <- dev_file[grepl("flat_", dev_file)]
# Inflate once
usethis::with_project(dummypackage_fixed, {
#  browser()
  suppressMessages(

    inflate(
      pkg = dummypackage_fixed, flat_file = flat_file,
      vignette_name = "Get started", check = FALSE,
      open_vignette = FALSE
    )
  )
})
# Add a not registered file to the package
cat("# test R file", file = file.path(dummypackage_fixed, "R", "to_keep.R"))


test_that("register_all_to_config can be run twice", {
  expect_true(inherits(register_all_to_config, "function"))

  usethis::with_project(dummypackage_fixed, {
    expect_error(
      out_path <- register_all_to_config(dummypackage_fixed),
      regexp = NA
    )
    expect_equal(out_path, file.path("dev", "config_fusen.yaml"))

    # What happens if everything is already registered? ----
    expect_message(
      out_path <- register_all_to_config(dummypackage_fixed),
      regexp = "There is no file to register"
    )

    expect_equal(out_path, file.path("dev", "config_fusen.yaml"))

    # Add a new file to register from a new flat file ----
    add_flat_template(template = "add", flat_name = "new_one", open = FALSE)
    # Without vignette first
    inflate(pkg = dummypackage_fixed, flat_file = "dev/flat_new_one.Rmd", vignette_name = NA, check = FALSE, open_vignette = FALSE)

    expect_error(
      out_path <- register_all_to_config(dummypackage_fixed),
      regexp = NA
    )

    # With vignette then
    inflate(pkg = dummypackage_fixed, flat_file = "dev/flat_new_one.Rmd", vignette_name = "new_one", check = FALSE, open_vignette = FALSE)

    expect_error(
      out_path <- register_all_to_config(dummypackage_fixed),
      regexp = NA
    )
  })

  # yaml::read_yaml(out_path)
})

test_that("config file is correctly built after half register", {
  out_actual <- yaml::read_yaml(file.path(dummypackage_fixed, "dev", "config_fusen.yaml"))
  # To update
  # file.copy(file.path(dummypackage_fixed, "dev", "config_fusen.yaml"), here::here("tests/testthat/config_fusen_register.yaml"), overwrite = TRUE)
  if (file.exists("config_fusen_register.yaml")) {
    out_expected <- yaml::read_yaml("config_fusen_register.yaml")
  } else {
    # during dev in root directory
    out_expected <- yaml::read_yaml(here::here("tests/testthat/config_fusen_register.yaml"))
  }

  expect_equal(out_actual, out_expected)
})

unlink(dummypackage, recursive = TRUE)

# Test df_to_config with custom config file path ----
config_file_path <- tempfile(fileext = ".yaml")

test_that("df_to_config fails when appropriate", {
  withr::with_options(list(fusen.config_file = config_file_path), {
    all_files <- tibble::tribble(
      ~type, ~files,
      "R", "zaza.R",
      "R", "zozo.R",
      "test", "test-zaza.R"
    )

    expect_error(
      df_to_config(all_files, flat_file_path = "keep"),
      "df_files should contains two columns named: 'type' and 'path'"
    )

    all_files <- tibble::tribble(
      ~type, ~path,
      "R", "zaza.R",
      "R", "zozo.R",
      "test", "test-zaza.R"
    )

    expect_error(
      df_to_config(all_files),
      "Some 'path' in df_files do not exist: row 1- R: zaza.R, row 2- R: zozo.R, row 3- test: test-zaza.R"
    )
  })
})


# Create files, even empty
dir_tmp <- tempfile()
dir.create(dir_tmp)
file.create(file.path(dir_tmp, c("zaza.R", "zozo.R", "test-zaza.R", "toto.Rmd")))

test_that("df_to_config works", {
  withr::with_dir(dir_tmp, {
    withr::with_options(list(fusen.config_file = config_file_path), {
      # Use full path

      all_files <- tibble::tribble(
        ~type, ~path,
        "R", "zaza.R",
        "R", "zozo.R",
        "test", "test-zaza.R"
      )

    expect_message(config_file_out <- df_to_config(all_files))
    })

    expect_equal(config_file_out, config_file_path)
    all_keep <- yaml::read_yaml(config_file_out)
    expect_equal(names(all_keep), "keep")
    expect_equal(names(all_keep$keep), c("path", "state", "R", "tests", "vignettes"))
    expect_equal(all_keep$keep$path, c("keep"))
    expect_equal(all_keep$keep$state, c("active"))
    expect_equal(all_keep$keep$R, c("zaza.R", "zozo.R"))
    expect_equal(all_keep$keep$tests, c("test-zaza.R"))
    expect_equal(all_keep$keep$vignettes, list())
  })
})

# Second pass
all_files <- tibble::tribble(
  ~type, ~path,
  "r", "tata.R",
  "R", "toto.R",
  "tests", "test-tata.R",
  "vignettes", "tata_vignette.Rmd"
)

file.create(file.path(dir_tmp, c("tata.R", "toto.R", "test-tata.R", "tata_vignette.Rmd")))

test_that("df_to_config works after 2nd run", {
  withr::with_dir(dir_tmp, {
    withr::with_options(list(fusen.config_file = config_file_path), {
      expect_message(
        config_file <- df_to_config(all_files),
        regexp = "Some files group already existed and were overwritten: keep"
      ) # "keep" is default
    })
  })
})

unlink(dir_tmp, recursive = TRUE)
file.remove(config_file_path)

# Create files, even empty ----
dir_tmp <- tempfile()
dir.create(dir_tmp)
file.create(file.path(dir_tmp, c("zaza.R", "zozo.R", "test-zaza.R")))
dir.create(file.path(dir_tmp, "vignettes"))
file.create(file.path(dir_tmp, "vignettes", "my-vignette.Rmd"))

test_that("df_to_config works with files having no content", {
  withr::with_options(list(fusen.config_file = config_file_path), {
    withr::with_dir(dir_tmp, {

      # Use relative path
      all_files <- tibble::tribble(
        ~type, ~path,
        "R", "zaza.R",
        "R", "zozo.R",
        "test", "test-zaza.R",
        "vignette", file.path("vignettes", "my-vignette.Rmd")
      )

      expect_message(config_file_out <- df_to_config(all_files))
    })

    expect_equal(config_file_out, config_file_path)
    all_keep <- yaml::read_yaml(config_file_out)
    expect_equal(names(all_keep), "keep")
    expect_equal(names(all_keep$keep), c("path", "state", "R", "tests", "vignettes"))
    expect_equal(all_keep$keep$path, c("keep"))
    expect_equal(all_keep$keep$state, c("active"))
    # Relative path
    expect_equal(all_keep$keep$R, c("zaza.R", "zozo.R"))
    expect_equal(all_keep$keep$tests, c("test-zaza.R"))
    expect_equal(all_keep$keep$vignettes, c("vignettes/my-vignette.Rmd"))
  })
})

# Remove one file to see if it is detected ----
file.remove(file.path(dir_tmp, c("zaza.R")))
test_that("df_to_config works with files having no content", {
  withr::with_options(list(fusen.config_file = config_file_path), {
    withr::with_dir(dir_tmp, {

      # Use relative path
      all_files <- tibble::tribble(
        ~type, ~path,
        "R", "zaza.R",
        "R", "zozo.R",
        "test", "test-zaza.R",
        "vignette", file.path("vignettes", "my-vignette.Rmd")
      )

      expect_error(config_file_out <- df_to_config(all_files),
        regexp = "zaza.R"
      )
    })
  })
})

unlink(dir_tmp, recursive = TRUE)
file.remove(config_file_path)

# Verify df_to_config was run during Ã¬nflate()
dummypackage <- tempfile("clean")
dir.create(dummypackage)

# {fusen} steps
fill_description(pkg = dummypackage, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(add_flat_template(pkg = dummypackage, overwrite = TRUE, open = FALSE))
flat_file <- dev_file[grepl("flat_", dev_file)]
# Inflate once
usethis::with_project(dummypackage, {
  suppressMessages(
    inflate(
      pkg = dummypackage, flat_file = flat_file,
      vignette_name = "Get started", check = FALSE,
      open_vignette = FALSE,
      extra_param = "toto"
    )
  )

  config_yml <- yaml::read_yaml(file.path(dummypackage, "dev/config_fusen.yaml"))

  expect_equal(
    config_yml[[basename(flat_file)]][["inflate"]][["vignette_name"]],
    "Get started"
  )

  expect_false(
    config_yml[[basename(flat_file)]][["inflate"]][["check"]]
  )

  expect_false(
    config_yml[[basename(flat_file)]][["inflate"]][["open_vignette"]]
  )

  expect_true(
    config_yml[[basename(flat_file)]][["inflate"]][["document"]]
  )

  expect_equal(
    config_yml[[basename(flat_file)]][["inflate"]][["overwrite"]],
    "ask"
  )


  expect_equal(
    config_yml[[basename(flat_file)]][["inflate"]][["extra_param"]],
    "toto"
  )

  # Let's inflate a second time with different parameters

  suppressMessages(
    inflate(
      pkg = dummypackage, flat_file = flat_file,
      vignette_name = "Get started again", check = FALSE,
      open_vignette = FALSE, overwrite = "yes",
      extra_param = "tutu", document = FALSE
    )
  )

  config_yml <- yaml::read_yaml(file.path(dummypackage, "dev/config_fusen.yaml"))

  expect_equal(
    config_yml[[basename(flat_file)]][["inflate"]][["vignette_name"]],
    "Get started again"
  )

  expect_false(
    config_yml[[basename(flat_file)]][["inflate"]][["check"]]
  )

  expect_false(
    config_yml[[basename(flat_file)]][["inflate"]][["open_vignette"]]
  )

  expect_false(
    config_yml[[basename(flat_file)]][["inflate"]][["document"]]
  )

  expect_equal(
    config_yml[[basename(flat_file)]][["inflate"]][["overwrite"]],
    "yes"
  )


  expect_equal(
    config_yml[[basename(flat_file)]][["inflate"]][["extra_param"]],
    "tutu"
  )
})

unlink(dummypackage, recursive = TRUE)

# Test df_to_config with inflate parameters
config_file_path <- tempfile(fileext = ".yaml")
dir_tmp <- tempfile()
dir.create(dir_tmp)
file.create(file.path(dir_tmp, c("zaza.R", "zozo.R", "test-zaza.R", "toto.Rmd")))

test_that("df_to_config works with inflate_parameters", {
  withr::with_dir(dir_tmp, {
    withr::with_options(list(fusen.config_file = config_file_path), {

      all_files <- tibble::tribble(
        ~type, ~path,
        "R", "zaza.R",
        "R", "zozo.R",
        "test", "test-zaza.R"
      )

      df_to_config(all_files,
                   inflate_parameters = list(
                     pkg = ".",
                     flat_file = "dev/my_flat.Rmd",
                     vignette_name = "My new vignette",
                     open_vignette = FALSE,
                     check = FALSE,
                     document = TRUE,
                     overwrite = "yes"
                   ))

      config_file <- yaml::read_yaml(config_file_path)

      expect_equal(
        config_file[["keep"]][["inflate"]][["pkg"]],
        "."
      )

      expect_equal(
        config_file[["keep"]][["inflate"]][["flat_file"]],
        "dev/my_flat.Rmd"
      )

      expect_equal(
        config_file[["keep"]][["inflate"]][["vignette_name"]],
        "My new vignette"
      )

      expect_false(
        config_file[["keep"]][["inflate"]][["open_vignette"]]
      )

      expect_false(
        config_file[["keep"]][["inflate"]][["check"]]
      )

      expect_true(
        config_file[["keep"]][["inflate"]][["document"]]
      )

      expect_equal(
        config_file[["keep"]][["inflate"]][["overwrite"]],
        "yes"
      )
    })
  })
})

unlink(dir_tmp, recursive = TRUE)

# rstudioapi::navigateToFile(config_file)

dummypackage <- tempfile("registered")
dir.create(dummypackage)

# {fusen} steps
fill_description(pkg = dummypackage, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(add_flat_template(pkg = dummypackage, overwrite = TRUE, open = FALSE))
flat_file <- dev_file[grepl("flat_", dev_file)]

usethis::with_project(dummypackage, {
  test_that("check_not_registered_files returns message if empty", {
    expect_true(inherits(check_not_registered_files, "function"))

    # debugonce(check_not_registered_files)
    expect_message(check_not_registered_files(), "There are no files in the package")
  })

  # Inflate once
  suppressMessages(
    inflate(
      pkg = dummypackage, flat_file = flat_file,
      vignette_name = "Get started", check = FALSE,
      open_vignette = FALSE
    )
  )

  test_that("guess_flat_origin works", {
    guessed_path <- guess_flat_origin(file.path(dummypackage, "R", "my_median.R"))
    # Relative path
    expect_equal(guessed_path, file.path("dev", "flat_full.Rmd"))

    guessed_path <- guess_flat_origin(file.path(dummypackage, "dev", "0-dev_history.Rmd"))
    expect_true(grepl("No existing source path found", guessed_path))
  })

  test_that("check_not_registered_files works", {
    # All files were registered during inflate
    expect_true(file.exists(file.path(dummypackage, "dev", "config_fusen.yaml")))
    expect_message(out_csv <- check_not_registered_files(),
      regexp = "There are no unregistered files"
    )

    # Delete config file to check if al sub-functions work
    file.remove(file.path(dummypackage, "dev", "config_fusen.yaml"))
    expect_message(out_csv <- check_not_registered_files(),
      regexp = "Wrote not registered files in:  dev/config_not_registered.csv"
    )

    content_csv <- read.csv(out_csv, stringsAsFactors = FALSE)
    expect_true(all(names(content_csv) %in% c("type", "path", "origin")))
    expect_equal(content_csv[["type"]], c("R", "R", "test", "test", "vignette"))
    # Relative path
    expect_equal(
      content_csv[["path"]],
      c(
        "R/my_median.R",
        "R/my_other_median.R",
        "tests/testthat/test-my_median.R",
        "tests/testthat/test-my_other_median.R",
        "vignettes/get-started.Rmd"
      )
    )
  })

  test_that("guess_flat_origin output works with df_to_config", {
    out_csv <- "dev/config_not_registered.csv"
    # Include it in df_to_config()

    out_config <- df_to_config(
      df_files = out_csv,
      inflate_parameters = list(
        pkg = dummypackage, flat_file = flat_file,
        vignette_name = "Get started", check = FALSE,
        open_vignette = FALSE
      )
    )
    out_config_content <- yaml::read_yaml(out_config)
    expect_true(names(out_config_content) == "flat_full.Rmd")
    expect_equal(
      names(out_config_content[["flat_full.Rmd"]]),
      c("path", "state", "R", "tests", "vignettes", "inflate")
    )
    expect_equal(
      out_config_content[["flat_full.Rmd"]][["R"]],
      c("R/my_median.R", "R/my_other_median.R")
    )
    expect_equal(
      out_config_content[["flat_full.Rmd"]][["tests"]],
      c("tests/testthat/test-my_median.R", "tests/testthat/test-my_other_median.R")
    )
    expect_equal(
      out_config_content[["flat_full.Rmd"]][["vignettes"]],
      c("vignettes/get-started.Rmd")
    )

    expect_equal(
      out_config_content[["flat_full.Rmd"]][["inflate"]][-c(1, 2)],
      list(vignette_name = "Get started", check = FALSE, open_vignette = FALSE)
    )

    # rstudioapi::navigateToFile(out_config)
  })

  # Test add a R file manually and include in "keep" after `check_not_registered_files()`
  cat("# test R file", file = file.path(dummypackage, "R", "to_keep.R"))

  test_that("check_not_registered_files can help manually fill config", {
    expect_message(out_csv <- check_not_registered_files(), "Wrote not registered files")
    content_csv <- read.csv(out_csv, stringsAsFactors = FALSE)
    expect_true(
      grepl(
        "No existing source path found",
        content_csv[grepl("to_keep.R", content_csv[, "path"]), "origin"]
      )
    )

    # Add in the yaml file with `df_to_config()`
    keep_to_add_to_config <- content_csv[grepl("to_keep.R", content_csv[, "path"]), ]
    keep_to_add_to_config$origin <- "keep"

    out_config <- df_to_config(keep_to_add_to_config,
      inflate_parameters = list(
        pkg = dummypackage, flat_file = flat_file,
        vignette_name = "Get started", check = FALSE,
        open_vignette = FALSE
      )
    )
    # rstudioapi::navigateToFile(out_config)
    out_config_content <- yaml::read_yaml(out_config)
    expect_equal(out_config_content$keep$R, "R/to_keep.R")

    expect_message(
      out_csv <- check_not_registered_files(),
      "There are no unregistered files"
    )
    expect_true(is.null(out_csv))

    # Add same file in the yaml file with `df_to_config()` using different origin (existing one, but duplicate R file) ----

    keep_to_add_to_config$origin <- "dev/flat_full.Rmd"

    expect_error(
      df_to_config(keep_to_add_to_config,
        inflate_parameters = list(
          pkg = dummypackage, flat_file = flat_file,
          vignette_name = "Get started", check = FALSE,
          open_vignette = FALSE
        )
      ),
      "Some paths would appear multiple times in the future config file."
    )

    # Add same file in the yaml file with `df_to_config()` using different origin (not existing) ----

    keep_to_add_to_config$origin <- "dev/flat_dont_exists.Rmd"

    expect_error(
      df_to_config(keep_to_add_to_config,
        inflate_parameters = list(
          pkg = dummypackage, flat_file = flat_file,
          vignette_name = "Get started", check = FALSE,
          open_vignette = FALSE
        )
      ),
      "Some 'origin' in df_files do not exist: row 1: dev/flat_dont_exists.Rmd"
    )
  })
})


# Test full ----
# Change options(fusen.config_file = "dev/config_fusen.yaml")
dummypackage <- tempfile("clean")
dir.create(dummypackage)

# {fusen} steps
fill_description(pkg = dummypackage, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(add_flat_template(pkg = dummypackage, overwrite = TRUE, open = FALSE))
flat_file <- dev_file[grepl("flat_", dev_file)]

# Detect all files created ----
usethis::with_project(dummypackage, {
  # Create empty config file

  # Inflate once
  suppressMessages(
    inflate(
      pkg = dummypackage, flat_file = flat_file,
      vignette_name = "Get started", check = FALSE,
      open_vignette = FALSE
    )
  )

  # debugonce(inflate)
})
